(module ;; some simple math funcs, need i32 and i64 versions since wasm's pretty strict about types
  (func (export "abs_i32") (param $x i32) (result i32)
    (if (result i32)
      (i32.lt_s (local.get $x) (i32.const 0))
      (then (i32.sub (i32.const 0) (local.get $x)))
      (else (local.get $x))
    )
  )

  (func (export "abs_i64") (param $x i64) (result i64)
    (if (result i64)
      (i64.lt_s (local.get $x) (i64.const 0))
      (then (i64.sub (i64.const 0) (local.get $x)))
      (else (local.get $x))
    )
  )

  (func (export "clamp_i32") (param $x i32) (param $min i32) (param $max i32) (result i32)
    (local $tmp i32)
    ;; max(x, min)
    (local.set $tmp
      (if (result i32)
        (i32.lt_s (local.get $x) (local.get $min))
        (then (local.get $min))
        (else (local.get $x))
      )
    )
    ;; min(tmp, max)
    (if (result i32)
      (i32.gt_s (local.get $tmp) (local.get $max))
      (then (local.get $max))
      (else (local.get $tmp))
    )
  )

  (func (export "clamp_i64") (param $x i64) (param $min i64) (param $max i64) (result i64)
    (local $tmp i64)

    ;; max(x, min)
    (local.set $tmp
      (if (result i64)
        (i64.lt_s (local.get $x) (local.get $min))
        (then (local.get $min))
        (else (local.get $x))
      )
    )

    ;; min(tmp, max)
    (if (result i64)
      (i64.gt_s (local.get $tmp) (local.get $max))
      (then (local.get $max))
      (else (local.get $tmp))
    )
  )

  (func (export "prev_power_of_two_i32")
    (param $x i32)
    (result i32)
    (if (result i32)
      (i32.lt_s (local.get $x) (i32.const 1))
      (then (i32.const 0))
      (else
        (i32.shl
          (i32.const 1)
          (i32.sub
            (i32.const 31)
            (i32.clz (local.get $x))
          )
        )
      )
    )
  )

  (func (export "next_power_of_two_i32")
    (param $x i32)
    (result i32)
    (if (result i32)
      (i32.lt_s (local.get $x) (i32.const 1))
      (then (i32.const 1))
      (else
        (i32.shl
          (i32.const 1)
          (i32.sub
            (i32.const 32)
            (i32.clz
              (i32.sub (local.get $x) (i32.const 1))
            )
          )
        )
      )
    )
  )

  (func (export "prev_power_of_two_i64")
    (param $x i64)
    (result i64)
    (if (result i64)
      (i64.lt_s (local.get $x) (i64.const 1))
      (then (i64.const 0))
      (else
        (i64.shl
          (i64.const 1)
          (i64.sub
            (i64.const 63)
            (i64.clz (local.get $x))
          )
        )
      )
    )
  )

  (func (export "next_power_of_two_i64")
    (param $x i64)
    (result i64)
    (if (result i64)
      (i64.lt_s (local.get $x) (i64.const 1))
      (then (i64.const 1))
      (else
        (i64.shl
          (i64.const 1)
          (i64.sub
            (i64.const 64)
            (i64.clz
              (i64.sub (local.get $x) (i64.const 1))
            )
          )
        )
      )
    )
  )

  ;; max and min functions for i32
  (func $max_i32 (param $a i32) (param $b i32) (result i32)
    (if (result i32)
      (i32.gt_s (local.get $a) (local.get $b))
      (then (local.get $a))
      (else (local.get $b))
    )
  )

  (func $min_i32 (param $a i32) (param $b i32) (result i32)
    (if (result i32)
      (i32.lt_s (local.get $a) (local.get $b))
      (then (local.get $a))
      (else (local.get $b))
    )
  )
  
  ;; max and min functions for i64
  (func $max_i64 (param $a i64) (param $b i64) (result i64)
    (if (result i64)
      (i64.gt_s (local.get $a) (local.get $b))
      (then (local.get $a))
      (else (local.get $b))
    )
  )

  (func $min_i64 (param $a i64) (param $b i64) (result i64)
    (if (result i64)
      (i64.lt_s (local.get $a) (local.get $b))
      (then (local.get $a))
      (else (local.get $b))
    )
  )
)
